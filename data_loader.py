# -*- coding: utf-8 -*-
"""Data Loader.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10913t-S_2m_v-MQuKd-F317Pn7OruyJD
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import cv2
import platform
import pickle
import os
from zipfile import ZipFile
from sklearn.preprocessing import LabelEncoder


class DataLoader():
    def __init__(self, data_path = "/content/drive/MyDrive/Software Project/datasets/wdd_ground_truth", 
               ground_truth_file_path = "/content/drive/MyDrive/Software Project/datasets/ground_truth_wdd_angles.pickle",
               img_height = 60, image_width = 60):
        self.data = np.array([])
        self.labels = np.array([])
        self.labels_encoded = np.array([])
        self.data_path = data_path
        self.ground_truth_file_path = ground_truth_file_path
        self.max_frame_len = None
        self.img_height = img_height
        self.img_width = image_width
        self.slash = "/"
    
    def configure_data(self):
        
        videos = []
        data_path = self.data_path
        ground_truth_file_path = self.ground_truth_file_path
        img_height = self.img_height
        image_width = self.img_width
        
        # Validate the data folder and pickle paths to move forward to load the data
        if os.path.exists(self.data_path):
            pass
        else: raise Exception(f"The {data_path} path is a wrong path to access data folder! Enter correct path again to load data successfully!")
        if os.path.exists(ground_truth_file_path):
            pass
        else: raise Exception(f"The {self.ground_truth_file_path} path is a wrong path to access data folder! Enter correct path again to load data successfully!")
        
        # Check the system type
        import platform
        if platform.system() == "Windows":
            import pathlib
            
            temp = pathlib.PosixPath
            pathlib.PosixPath = pathlib.WindowsPath
            self.slash = "\\"
        else:
            self.slash = "/"
        
        # Load the ground truth file which contains arranged file paths of video data 
        pickle_file = open("/content/drive/MyDrive/Software Project/datasets/ground_truth_wdd_angles.pickle", "rb")
        data = []
        data.append(pickle.load(pickle_file))
        
        # Data has been prepared to use 
        return data[0]
    
    def find_max_frame_length(self, data, verbose = False):
        from tqdm.auto import tqdm
        slash = self.slash
        max_frame_len = 0
        try:
            for ids in tqdm(data):
                #print(sequence)
                path = str(data[ids][2]).split(slash)[6:-1]
                label = data[ids][0]
                video_folder = os.path.join(*path)
                video_path = os.path.join(self.data_path, video_folder)
                video_path = os.path.join(video_path, "images.zip")
                #image_data_list.append(sequence)
                try:
                    with ZipFile(video_path, "r") as zip_ref:
                        frames = zip_ref.namelist()
                        if len(frames) > max_frame_len:
                            max_frame_len = len(frames)
                except:
                    print("Error in Retrieving Image data!")
        except ValueError:
            print("Error found in retrieving files path or folder path!")
        
        self.max_frame_len = max_frame_len
        return max_frame_len
    
    
    def extract_data(self, data):
        
        from tqdm.auto import tqdm
        data_path = self.data_path
        slash = self.slash
        img_height = self.img_height
        img_width = self.img_width
        
        # Finding the maximum frames length from all videos
        #data = self.configure_data()
        #if max_frame_len == None:
            #  max_frame_len = self.find_max_frame_length(data)
        videos_data = np.array([])
        videos_label = np.array([])
        
        try:
            for ids in tqdm(data):
                video = []
                
                # Path of files inside video data folder
                video_path = str(data[ids][2]).split(slash)[6:-1]
                # Similarly for labels
                
                label = data[ids][0]
                
                #Joining the directories to get paths of each video
                video_folder = os.path.join(*video_path)
                video_path = os.path.join(data_path, video_folder)
                video_path = os.path.join(video_path, "images.zip")
                
                #image_data_list.append(sequence)
                try:
                    with ZipFile(video_path, "r") as zip_ref:
                        frames = zip_ref.namelist()
                        for image in frames:
                            ext = os.path.splitext(image)[-1]      #.png
                            if ext == ".png" or ext == ".jpg":
                                img_data = zip_ref.read(image)
                                img = cv2.imdecode(np.frombuffer(img_data, np.uint8), 0)   # '1' for RGB, '0' for grayscale
                                img = cv2.resize(img, (img_height, img_width))
                                #print(img.shape)
                                video.append(img)
                except:
                    print("Error in Retrieving Image data!")
                
                # Storing first video when video data list is empty
                frame_len_diff = max_frame_len - len(video)
                video_data_after_padding = np.append(np.array(video), np.zeros((frame_len_diff, img_height, img_width)), axis = 0)
                if videos_data.size == 0:
                    videos_data = video_data_after_padding.reshape(1, max_frame_len, img_height, img_width).copy()
                    videos_label = np.append(videos_label, label)
                    continue
                videos_data = np.append(videos_data, video_data_after_padding.reshape(1, max_frame_len, img_height, img_width), axis = 0)
                videos_label = np.append(videos_label, label)
                video_data_after_padding = np.array([])
        except ValueError:
            print("Error found in retrieving files path or setting folder path!")
        
        #Saving the videos data into class variable "data"
        self.data = videos_data
        self.labels = videos_label
        
        # Label Encoding
        le = LabelEncoder()
        videos_label_encoded = le.fit_transform(videos_label)
        
        # Encoding the videos label and storing the data in self.labels_encoded
        self.labels_encoded = videos_label_encoded
        
        # Returning the videos data and videos label
        return videos_data, videos_label_encoded
    
    
    
    def load_data(self, data_file = None, label_file = None):
        if data_file == None and label_file == None:
            data = self.configure_data()
            #Check whether the maximum frame length in all videos is already found or not
            if self.max_frame_len == None:
                self.max_frame_len = self.find_max_frame_length(data)
                videos_data, labels_data = self.extract_data(data)
                return videos_data, labels_data
        
        elif data_file == None or label_file == None:
            ext = ".pickle"
            if data_file == None or (not os.path.exists(data_file)) or len(data_file) < 7 or data_file[-7:] != ext:
                raise Exception("Please enter filename (correctly) that contains video data and try again!")
            if label_file == None or (not os.path.exists(label_file)) or len(label_file) < 7 or label_file[-7:] != ext:
                raise Exception("Please enter filename (correctly) that contains labels of video and try again!")   
        
        else:
            try:
                #Load the data if file names are given as input
                videos_data = pickle.load(open(data_file, "rb"))
                videos_label = pickle.load(open(label_file, "rb"))
            except:
                raise Exception("Error in loading files! Either files are corrupt or data is not relevant to honeybees videos. Please use appropriate files.")
                
        #Save the data in Data Loader Class variables
        self.data = videos_data
        self.labels_encoded = videos_label
        
        #Return the data
        return videos_data, videos_label
    
    
    
    def save_data(self, videos_data = None , videos_label = None, data_file = "X.pickle", target_class_file = "Y.pickle"):
        # If no data is provided in input, then check whether the data is stored previously in Data Loader class
        #If there is no data found in this class, then to insure the reliability, user will get feedback to load data again
        if not np.size(videos_data) or not np.size(videos_label):
            if not np.size(self.data) or not np.size(self.labels_encoded):
                raise Exception("Please load data first before trying to execute save function!")
                
        if not np.size(videos_data):
            videos_data = self.data
        if not np.size(videos_label):
            videos_label = self.labels_encoded
        
        # Label Encoding to get information about class distribution of videos label feature
        class_info_flag = False
        if np.size(self.labels):
            class_info_flag = True
            le = LabelEncoder()
            class_name = pd.Series(videos_label).value_counts().index
            class_encode = le.fit_transform(pd.Series(videos_label).value_counts().index)
            y = le.fit_transform(videos_label)
            class_dist = pd.Series(y).value_counts().values
            
            class_info = dict()
            class_info["class_name"] = class_name
            class_info["class_encode_number"] = class_encode
            class_info["class_dist"] = class_dist
            class_df = pd.DataFrame(class_info)
            class_df.to_csv("target_class_information.csv", index = False)
        
        ext = ".pickle"
        
        #Validating to store video_data
        if len(data_file) > 7 or data_file[-7:] == ext:
            pass
        else:
            data_file = "Y.pickle"
        
        #Validating to store target class name
        if len(target_class_file) > 7 or target_class_file[-7:] == ext:
            pass
        else:
            target_class_file = "Y.pickle"
        
        
        # Store the data in pickle file
        pickle_out = open(data_file, "wb")
        pickle.dump(videos_data, pickle_out)
        pickle_out.close()
        
        # Store the target class feature in pickle file
        pickle_out = open(target_class_file, "wb")
        pickle.dump(videos_label, pickle_out)
        pickle_out.close()
        
        # Success Message
        print("Videos data and it's target class labels are successfully saved in seperate files in the current working directory!")
        if class_info_flag:
            print("Videos label information is also saved in a file (target_class_information.csv).")



if __name__ == "__main__":
    print("True")
    dl = DataLoader()
    data = dl.configure_data()



#dl.data_path

#max_frame_len = dl.find_max_frame_length(data)
#print(max_frame_len)

#dl.max_frame_len

#data, labels = dl.load_data(None, None)

#pickle.dump(data[:100], open("X.pickle", "wb"))
#pickle.dump(labels[:100], open("Y.pickle", "wb"))

#data = pickle.load(open("X.pickle", "rb"))
#labels = pickle.load(open("Y.pickle", "rb"))
#labels = labels[:100]

#data.shape, labels.shape

#labels[:5]

#dl.data.shape, dl.labels_encoded.shape

#dl.save_data(data, labels)